--
-- Autogenerated by Thrift
--
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
-- @generated
--


 -- require 'hbase_constants'

local Thrift =require 'Thrift' 
 
local ttype = Thrift.ttype 
local terror = Thrift.terror 
local ttable_size = Thrift.ttable_size 
local TType = Thrift.TType 
local TMessageType = Thrift.TMessageType 
local __TObject = Thrift. __TObject 
local thrift_print_r = Thrift.thrift_print_r 
local TException = Thrift.TException 
local TApplicationException = Thrift.TApplicationException 
local __TClient = Thrift.__TClient 
local __TProcessor= Thrift.__TProcessor

local TDeleteType = {
  DELETE_COLUMN = 0,
  DELETE_COLUMNS = 1
}

local TDurability = {
  SKIP_WAL = 1,
  ASYNC_WAL = 2,
  SYNC_WAL = 3,
  FSYNC_WAL = 4
}

local TTimeRange = __TObject:new{
  minStamp = nil,

  maxStamp = nil
}

function TTimeRange:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I64 then
        self.minStamp = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.maxStamp = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TTimeRange:write(oprot)
  oprot:writeStructBegin('TTimeRange')
  if self.minStamp ~= nil then
    oprot:writeFieldBegin('minStamp', TType.I64, 1)
    oprot:writeI64(self.minStamp)
    oprot:writeFieldEnd()
  end
  if self.maxStamp ~= nil then
    oprot:writeFieldBegin('maxStamp', TType.I64, 2)
    oprot:writeI64(self.maxStamp)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

local TColumn = __TObject:new{
  family = nil,
  qualifier = nil,
  timestamp = nil
}

function TColumn:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.family = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.qualifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.timestamp = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TColumn:write(oprot)
  oprot:writeStructBegin('TColumn')
  if self.family ~= nil then
    oprot:writeFieldBegin('family', TType.STRING, 1)
    oprot:writeString(self.family)
    oprot:writeFieldEnd()
  end
  if self.qualifier ~= nil then
    oprot:writeFieldBegin('qualifier', TType.STRING, 2)
    oprot:writeString(self.qualifier)
    oprot:writeFieldEnd()
  end
  if self.timestamp ~= nil then
    oprot:writeFieldBegin('timestamp', TType.I64, 3)
    oprot:writeI64(self.timestamp)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

local TColumnValue = __TObject:new{
  family = nil,
  qualifier= nil,
  value = nil,
  timestamp = nil,
  tags = nil
}

function TColumnValue:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.family = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.qualifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.value = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I64 then
        self.timestamp = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.tags = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TColumnValue:write(oprot)
  oprot:writeStructBegin('TColumnValue')
  if self.family ~= nil then
    oprot:writeFieldBegin('family', TType.STRING, 1)
    oprot:writeString(self.family)
    oprot:writeFieldEnd()
  end
  if self.qualifier ~= nil then
    oprot:writeFieldBegin('qualifier', TType.STRING, 2)
    oprot:writeString(self.qualifier)
    oprot:writeFieldEnd()
  end
  if self.value ~= nil then
    oprot:writeFieldBegin('value', TType.STRING, 3)
    oprot:writeString(self.value)
    oprot:writeFieldEnd()
  end
  if self.timestamp ~= nil then
    oprot:writeFieldBegin('timestamp', TType.I64, 4)
    oprot:writeI64(self.timestamp)
    oprot:writeFieldEnd()
  end
  if self.tags ~= nil then
    oprot:writeFieldBegin('tags', TType.STRING, 5)
    oprot:writeString(self.tags)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

local TColumnIncrement = __TObject:new{
  family = nil,
  qualifier = nil ,
  amount = nil
}

function TColumnIncrement:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.family = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.qualifier = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.amount = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TColumnIncrement:write(oprot)
  oprot:writeStructBegin('TColumnIncrement')
  if self.family ~= nil then
    oprot:writeFieldBegin('family', TType.STRING, 1)
    oprot:writeString(self.family)
    oprot:writeFieldEnd()
  end
  if self.qualifier ~= nil then
    oprot:writeFieldBegin('qualifier', TType.STRING, 2)
    oprot:writeString(self.qualifier)
    oprot:writeFieldEnd()
  end
  if self.amount ~= nil then
    oprot:writeFieldBegin('amount', TType.I64, 3)
    oprot:writeI64(self.amount)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

local TResult = __TObject:new{
  row = nil,
  columnValues = nil
}

function TResult:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.row = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.columnValues = {}
        local _etype3, _size0 = iprot:readListBegin()
        for _i=1,_size0 do
          local _elem4 = TColumnValue:new{}
          _elem4:read(iprot)
          table.insert(self.columnValues, _elem4)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TResult:write(oprot)
  oprot:writeStructBegin('TResult')
  if self.row ~= nil then
    oprot:writeFieldBegin('row', TType.STRING, 1)
    oprot:writeString(self.row)
    oprot:writeFieldEnd()
  end
  if self.columnValues ~= nil then
    oprot:writeFieldBegin('columnValues', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.columnValues)
    for _,iter5 in ipairs(self.columnValues) do
      iter5:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

local TAuthorization = __TObject:new{
  labels = nil
}

function TAuthorization:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.labels = {}
        local _etype9, _size6 = iprot:readListBegin()
        for _i=1,_size6 do
          local _elem10 = iprot:readString()
          table.insert(self.labels, _elem10)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TAuthorization:write(oprot)
  oprot:writeStructBegin('TAuthorization')
  if self.labels ~= nil then
    oprot:writeFieldBegin('labels', TType.LIST, 1)
    oprot:writeListBegin(TType.STRING, #self.labels)
    for _,iter11 in ipairs(self.labels) do
      oprot:writeString(iter11)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

local TCellVisibility = __TObject:new{
  expression = nil
}

function TCellVisibility:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.expression = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TCellVisibility:write(oprot)
  oprot:writeStructBegin('TCellVisibility')
  if self.expression ~= nil then
    oprot:writeFieldBegin('expression', TType.STRING, 1)
    oprot:writeString(self.expression)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

local TGet = __TObject:new{
  row = nil,
  columns = nil,
  timestamp = nil ,
  timeRange = nil,
  maxVersions = nil,
  filterString = nil,
  attributes = nil,
  authorizations = nil
}

function TGet:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.row = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.columns = {}
        local _etype15, _size12 = iprot:readListBegin()
        for _i=1,_size12 do
          local _elem16 = TColumn:new{}
          _elem16:read(iprot)
          table.insert(self.columns, _elem16)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.timestamp = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRUCT then
        self.timeRange = TTimeRange:new{}
        self.timeRange:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I32 then
        self.maxVersions = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRING then
        self.filterString = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.MAP then
        self.attributes = {}
        local _ktype18, _vtype19, _size17 = iprot:readMapBegin() 
        for _i=1,_size17 do
          local _key21 = iprot:readString()
          local _val22 = iprot:readString()
          self.attributes[_key21] = _val22
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 8 then
      if ftype == TType.STRUCT then
        self.authorizations = TAuthorization:new{}
        self.authorizations:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TGet:write(oprot)
  oprot:writeStructBegin('TGet')
  if self.row ~= nil then
    oprot:writeFieldBegin('row', TType.STRING, 1)
    oprot:writeString(self.row)
    oprot:writeFieldEnd()
  end
  if self.columns ~= nil then
    oprot:writeFieldBegin('columns', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.columns)
    for _,iter23 in ipairs(self.columns) do
      iter23:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.timestamp ~= nil then
    oprot:writeFieldBegin('timestamp', TType.I64, 3)
    oprot:writeI64(self.timestamp)
    oprot:writeFieldEnd()
  end
  if self.timeRange ~= nil then
    oprot:writeFieldBegin('timeRange', TType.STRUCT, 4)
    self.timeRange:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.maxVersions ~= nil then
    oprot:writeFieldBegin('maxVersions', TType.I32, 5)
    oprot:writeI32(self.maxVersions)
    oprot:writeFieldEnd()
  end
  if self.filterString ~= nil then
    oprot:writeFieldBegin('filterString', TType.STRING, 6)
    oprot:writeString(self.filterString)
    oprot:writeFieldEnd()
  end
  if self.attributes ~= nil then
    oprot:writeFieldBegin('attributes', TType.MAP, 7)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.attributes))
    for kiter24,viter25 in pairs(self.attributes) do
      oprot:writeString(kiter24)
      oprot:writeString(viter25)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.authorizations ~= nil then
    oprot:writeFieldBegin('authorizations', TType.STRUCT, 8)
    self.authorizations:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

local TPut = __TObject:new{
  row = nil,
  columnValues = nil,
  timestamp = nil ,
  attributes = nil ,
  durability = nil,
  cellVisibility = nil
}

function TPut:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.row = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.columnValues = {}
        local _etype29, _size26 = iprot:readListBegin()
        for _i=1,_size26 do
          local _elem30 = TColumnValue:new{}
          _elem30:read(iprot)
          table.insert(self.columnValues, _elem30)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.timestamp = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.MAP then
        self.attributes = {}
        local _ktype32, _vtype33, _size31 = iprot:readMapBegin() 
        for _i=1,_size31 do
          local _key35 = iprot:readString()
          local _val36 = iprot:readString()
          self.attributes[_key35] = _val36
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.I32 then
        self.durability = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRUCT then
        self.cellVisibility = TCellVisibility:new{}
        self.cellVisibility:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TPut:write(oprot)
  oprot:writeStructBegin('TPut')
  if self.row ~= nil then
    oprot:writeFieldBegin('row', TType.STRING, 1)
    oprot:writeString(self.row)
    oprot:writeFieldEnd()
  end
  if self.columnValues ~= nil then
    oprot:writeFieldBegin('columnValues', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.columnValues)
    for _,iter37 in ipairs(self.columnValues) do
      iter37:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.timestamp ~= nil then
    oprot:writeFieldBegin('timestamp', TType.I64, 3)
    oprot:writeI64(self.timestamp)
    oprot:writeFieldEnd()
  end
  if self.attributes ~= nil then
    oprot:writeFieldBegin('attributes', TType.MAP, 5)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.attributes))
    for kiter38,viter39 in pairs(self.attributes) do
      oprot:writeString(kiter38)
      oprot:writeString(viter39)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.durability ~= nil then
    oprot:writeFieldBegin('durability', TType.I32, 6)
    oprot:writeI32(self.durability)
    oprot:writeFieldEnd()
  end
  if self.cellVisibility ~= nil then
    oprot:writeFieldBegin('cellVisibility', TType.STRUCT, 7)
    self.cellVisibility:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

local TDelete = __TObject:new{
  row = nil,
  columns = nil,
  timestamp= nil ,
  deleteType= nil,
  attributes = nil,
  durability =nil
}

function TDelete:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.row = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.columns = {}
        local _etype43, _size40 = iprot:readListBegin()
        for _i=1,_size40 do
          local _elem44 = TColumn:new{}
          _elem44:read(iprot)
          table.insert(self.columns, _elem44)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.timestamp = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.deleteType = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.MAP then
        self.attributes = {}
        local _ktype46, _vtype47, _size45 = iprot:readMapBegin() 
        for _i=1,_size45 do
          local _key49 = iprot:readString()
          local _val50 = iprot:readString()
          self.attributes[_key49] = _val50
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.I32 then
        self.durability = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TDelete:write(oprot)
  oprot:writeStructBegin('TDelete')
  if self.row ~= nil then
    oprot:writeFieldBegin('row', TType.STRING, 1)
    oprot:writeString(self.row)
    oprot:writeFieldEnd()
  end
  if self.columns ~= nil then
    oprot:writeFieldBegin('columns', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.columns)
    for _,iter51 in ipairs(self.columns) do
      iter51:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.timestamp ~= nil then
    oprot:writeFieldBegin('timestamp', TType.I64, 3)
    oprot:writeI64(self.timestamp)
    oprot:writeFieldEnd()
  end
  if self.deleteType ~= nil then
    oprot:writeFieldBegin('deleteType', TType.I32, 4)
    oprot:writeI32(self.deleteType)
    oprot:writeFieldEnd()
  end
  if self.attributes ~= nil then
    oprot:writeFieldBegin('attributes', TType.MAP, 6)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.attributes))
    for kiter52,viter53 in pairs(self.attributes) do
      oprot:writeString(kiter52)
      oprot:writeString(viter53)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.durability ~= nil then
    oprot:writeFieldBegin('durability', TType.I32, 7)
    oprot:writeI32(self.durability)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

local TIncrement = __TObject:new{
  row = nil,
  columns = nil ,
  attributes = nil,
  durability = nil,
  cellVisibility = nil
}

function TIncrement:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.row = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.columns = {}
        local _etype57, _size54 = iprot:readListBegin()
        for _i=1,_size54 do
          local _elem58 = TColumnIncrement:new{}
          _elem58:read(iprot)
          table.insert(self.columns, _elem58)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.MAP then
        self.attributes = {}
        local _ktype60, _vtype61, _size59 = iprot:readMapBegin() 
        for _i=1,_size59 do
          local _key63 = iprot:readString()
          local _val64 = iprot:readString()
          self.attributes[_key63] = _val64
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I32 then
        self.durability = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRUCT then
        self.cellVisibility = TCellVisibility:new{}
        self.cellVisibility:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TIncrement:write(oprot)
  oprot:writeStructBegin('TIncrement')
  if self.row ~= nil then
    oprot:writeFieldBegin('row', TType.STRING, 1)
    oprot:writeString(self.row)
    oprot:writeFieldEnd()
  end
  if self.columns ~= nil then
    oprot:writeFieldBegin('columns', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.columns)
    for _,iter65 in ipairs(self.columns) do
      iter65:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.attributes ~= nil then
    oprot:writeFieldBegin('attributes', TType.MAP, 4)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.attributes))
    for kiter66,viter67 in pairs(self.attributes) do
      oprot:writeString(kiter66)
      oprot:writeString(viter67)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.durability ~= nil then
    oprot:writeFieldBegin('durability', TType.I32, 5)
    oprot:writeI32(self.durability)
    oprot:writeFieldEnd()
  end
  if self.cellVisibility ~= nil then
    oprot:writeFieldBegin('cellVisibility', TType.STRUCT, 6)
    self.cellVisibility:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

local TAppend = __TObject:new{
  row = nil,
  columns = nil ,
  attributes = nil ,
  durability = nil,
  cellVisibility = nil
}

function TAppend:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.row = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.columns = {}
        local _etype71, _size68 = iprot:readListBegin()
        for _i=1,_size68 do
          local _elem72 = TColumnValue:new{}
          _elem72:read(iprot)
          table.insert(self.columns, _elem72)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.MAP then
        self.attributes = {}
        local _ktype74, _vtype75, _size73 = iprot:readMapBegin() 
        for _i=1,_size73 do
          local _key77 = iprot:readString()
          local _val78 = iprot:readString()
          self.attributes[_key77] = _val78
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.durability = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRUCT then
        self.cellVisibility = TCellVisibility:new{}
        self.cellVisibility:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TAppend:write(oprot)
  oprot:writeStructBegin('TAppend')
  if self.row ~= nil then
    oprot:writeFieldBegin('row', TType.STRING, 1)
    oprot:writeString(self.row)
    oprot:writeFieldEnd()
  end
  if self.columns ~= nil then
    oprot:writeFieldBegin('columns', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.columns)
    for _,iter79 in ipairs(self.columns) do
      iter79:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.attributes ~= nil then
    oprot:writeFieldBegin('attributes', TType.MAP, 3)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.attributes))
    for kiter80,viter81 in pairs(self.attributes) do
      oprot:writeString(kiter80)
      oprot:writeString(viter81)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.durability ~= nil then
    oprot:writeFieldBegin('durability', TType.I32, 4)
    oprot:writeI32(self.durability)
    oprot:writeFieldEnd()
  end
  if self.cellVisibility ~= nil then
    oprot:writeFieldBegin('cellVisibility', TType.STRUCT, 5)
    self.cellVisibility:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

local TScan = __TObject:new{
  startRow = nil,
  stopRow = nil,
  columns = nil,
  caching = nil,
  maxVersions= nil,
  timeRange = nil,
  filterString = nil,
  batchSize = nil,
  attributes = nil,
  authorizations = nil,
  reversed = nil,
  cacheBlocks = nil
}

function TScan:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.startRow = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.stopRow = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.columns = {}
        local _etype85, _size82 = iprot:readListBegin()
        for _i=1,_size82 do
          local _elem86 = TColumn:new{}
          _elem86:read(iprot)
          table.insert(self.columns, _elem86)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.caching = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I32 then
        self.maxVersions = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.STRUCT then
        self.timeRange = TTimeRange:new{}
        self.timeRange:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRING then
        self.filterString = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 8 then
      if ftype == TType.I32 then
        self.batchSize = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 9 then
      if ftype == TType.MAP then
        self.attributes = {}
        local _ktype88, _vtype89, _size87 = iprot:readMapBegin() 
        for _i=1,_size87 do
          local _key91 = iprot:readString()
          local _val92 = iprot:readString()
          self.attributes[_key91] = _val92
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 10 then
      if ftype == TType.STRUCT then
        self.authorizations = TAuthorization:new{}
        self.authorizations:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 11 then
      if ftype == TType.BOOL then
        self.reversed = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 12 then
      if ftype == TType.BOOL then
        self.cacheBlocks = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TScan:write(oprot)
  oprot:writeStructBegin('TScan')
  if self.startRow ~= nil then
    oprot:writeFieldBegin('startRow', TType.STRING, 1)
    oprot:writeString(self.startRow)
    oprot:writeFieldEnd()
  end
  if self.stopRow ~= nil then
    oprot:writeFieldBegin('stopRow', TType.STRING, 2)
    oprot:writeString(self.stopRow)
    oprot:writeFieldEnd()
  end
  if self.columns ~= nil then
    oprot:writeFieldBegin('columns', TType.LIST, 3)
    oprot:writeListBegin(TType.STRUCT, #self.columns)
    for _,iter93 in ipairs(self.columns) do
      iter93:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.caching ~= nil then
    oprot:writeFieldBegin('caching', TType.I32, 4)
    oprot:writeI32(self.caching)
    oprot:writeFieldEnd()
  end
  if self.maxVersions ~= nil then
    oprot:writeFieldBegin('maxVersions', TType.I32, 5)
    oprot:writeI32(self.maxVersions)
    oprot:writeFieldEnd()
  end
  if self.timeRange ~= nil then
    oprot:writeFieldBegin('timeRange', TType.STRUCT, 6)
    self.timeRange:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.filterString ~= nil then
    oprot:writeFieldBegin('filterString', TType.STRING, 7)
    oprot:writeString(self.filterString)
    oprot:writeFieldEnd()
  end
  if self.batchSize ~= nil then
    oprot:writeFieldBegin('batchSize', TType.I32, 8)
    oprot:writeI32(self.batchSize)
    oprot:writeFieldEnd()
  end
  if self.attributes ~= nil then
    oprot:writeFieldBegin('attributes', TType.MAP, 9)
    oprot:writeMapBegin(TType.STRING, TType.STRING, ttable_size(self.attributes))
    for kiter94,viter95 in pairs(self.attributes) do
      oprot:writeString(kiter94)
      oprot:writeString(viter95)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.authorizations ~= nil then
    oprot:writeFieldBegin('authorizations', TType.STRUCT, 10)
    self.authorizations:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.reversed ~= nil then
    oprot:writeFieldBegin('reversed', TType.BOOL, 11)
    oprot:writeBool(self.reversed)
    oprot:writeFieldEnd()
  end
  if self.cacheBlocks ~= nil then
    oprot:writeFieldBegin('cacheBlocks', TType.BOOL, 12)
    oprot:writeBool(self.cacheBlocks)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

local TMutation = __TObject:new{
  put = nil,
  deleteSingle = nil 
}

function TMutation:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.put = TPut:new{}
        self.put:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.deleteSingle = TDelete:new{}
        self.deleteSingle:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TMutation:write(oprot)
  oprot:writeStructBegin('TMutation')
  if self.put ~= nil then
    oprot:writeFieldBegin('put', TType.STRUCT, 1)
    self.put:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.deleteSingle ~= nil then
    oprot:writeFieldBegin('deleteSingle', TType.STRUCT, 2)
    self.deleteSingle:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

local TRowMutations = __TObject:new{
  row = nil,
  mutations = nil 
}

function TRowMutations:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.row = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.mutations = {}
        local _etype99, _size96 = iprot:readListBegin()
        for _i=1,_size96 do
          local _elem100 = TMutation:new{}
          _elem100:read(iprot)
          table.insert(self.mutations, _elem100)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TRowMutations:write(oprot)
  oprot:writeStructBegin('TRowMutations')
  if self.row ~= nil then
    oprot:writeFieldBegin('row', TType.STRING, 1)
    oprot:writeString(self.row)
    oprot:writeFieldEnd()
  end
  if self.mutations ~= nil then
    oprot:writeFieldBegin('mutations', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.mutations)
    for _,iter101 in ipairs(self.mutations) do
      iter101:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

local TIOError = TException:new{
  __type = 'TIOError',
  message = nil
}

function TIOError:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.message = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TIOError:write(oprot)
  oprot:writeStructBegin('TIOError')
  if self.message ~= nil then
    oprot:writeFieldBegin('message', TType.STRING, 1)
    oprot:writeString(self.message)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

local TIllegalArgument = TException:new{
  __type = 'TIllegalArgument',
  message = nil
}

function TIllegalArgument:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.message = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function TIllegalArgument:write(oprot)
  oprot:writeStructBegin('TIllegalArgument')
  if self.message ~= nil then
    oprot:writeFieldBegin('message', TType.STRING, 1)
    oprot:writeString(self.message)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

return {
TTimeRange = TTimeRange,
TColumn= TColumn,
TColumnValue= TColumnValue,
TColumnIncrement =TColumnIncrement,
TResult =TResult,
TAuthorization=TAuthorization,
TCellVisibility=TCellVisibility,
TGet=TGet,
TPut=TPut,
TDelete=TDelete,
TIncrement=TIncrement,
TAppend=TAppend, TScan=TScan,
TMutation= TMutation,
TRowMutations= TRowMutations,
TIOError= TIOError,
TIllegalArgument= TIllegalArgument
}
